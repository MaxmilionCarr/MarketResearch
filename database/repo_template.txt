from __future__ import annotations
import sqlite3 as sql
from typing import Optional, List, Tuple, Any

class BaseRepository:
    """
    Generic Repository Template for a single table.

    === HOW TO USE ===
    1. Copy this file and rename the class (e.g. TickerRepository).
    2. Replace:
         - TABLE_NAME with the actual table.
         - COLUMNS list and SELECT columns in each query.
         - The type hints for rows (Tuple[â€¦]).
         - Add/modify methods if your table needs special behaviour
           (e.g. joins, filtering by date).
    3. Adjust docstrings to match the schema.

    Schema example:
        id INTEGER PRIMARY KEY,
        name TEXT NOT NULL,
        created_at DATETIME
    """

    TABLE_NAME = "your_table"            # <-- TODO: replace
    ID_COL     = "id"                    # <-- TODO: primary key column name
    COLUMNS    = ["id", "name", "created_at"]  # <-- TODO: full list of columns

    def __init__(self, connection: sql.Connection):
        self.connection = connection
        self.connection.execute("PRAGMA foreign_keys = ON")

    # ---------- READ ----------

    def get_all(self) -> List[Tuple[Any, ...]]:
        """
        Return all rows as a list of tuples matching COLUMNS.
        """

    def get_info(self, row_id: int) -> Optional[Tuple[Any, ...]]:
        """
        Return a single row by primary key or None if not found.
        """

    # ---------- CREATE ----------

    def create(self, **kwargs) -> int:
        """
        Insert a new row and return its primary key.
        Pass column=value pairs as kwargs.

        Example:
            repo.create(name="ASX", created_at="2025-01-01")
        """

    def get_or_create(self, unique_col: str, unique_val: Any, **defaults) -> int:
        """
        Return the ID of a row where unique_col == unique_val,
        or create it using defaults if it doesn't exist.
        """

    # ---------- UPDATE ----------

    def update(self, row_id: int, **kwargs) -> int:
        """
        Update given columns for a row.
        Returns number of rows updated.
        """

    # ---------- DELETE ----------

    def delete(self, *, row_id: Optional[int] = None, **filters) -> int:
        """
        Delete a row by primary key OR by custom filters.
        Returns number of rows deleted.
        """

    def delete_all(self) -> int:
        """
        Delete ALL rows from this table.
        Returns number of rows deleted.
        """
